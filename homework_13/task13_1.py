__all__ = ["bubble_sort", "insertion_sort", "quick_sort"]


def bubble_sort(arr):
    """Сортировка с помощью пузырькового метода. Сортировка пузырьком - это
    метод сортировки массивов и списков путем последовательного сравнения и
    обмена соседних элементов, если предшествующий оказывается больше
    последующего. В процессе выполнения данного алгоритма элементы с большими
    значениями оказываются в конце списка, а элементы с меньшими значениями
    постепенно перемещаются по направлению к началу списка. Образно говоря,
    тяжелые элементы падают на дно, а легкие медленно всплывают подобно
    пузырькам воздуха. В сортировке методом пузырька количество итераций
    внешнего цикла определяется длинной списка минус единица, так как когда
    второй элемент становится на свое место, то первый уже однозначно
    минимальный и находится на своем месте. Количество итераций внутреннего
    цикла зависит от номера итерации внешнего цикла, так как конец списка уже
    отсортирован, и выполнять проход по этим элементам смысла нет. """
    # определяем длину масива
    n = len(arr)
    # Внешний цикл кол-во проходов n-1
    for i in range(n - 1):
        # Внутренний цикл проходим от n - 2 до i - 1 проходов двигаясь с конца
        for j in range(n - 2, i - 1, -1):
            # Меняем элементы местами
            if arr[j + 1] < arr[j]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]


def insertion_sort(nums):
    """Предполагается, что первый элемент списка отсортирован. Переходим к
    следующему элементу, обозначим его х. Если х больше первого, оставляем
    его на своём месте. Если он меньше, копируем его на вторую позицию,
    а х устанавливаем как первый элемент.

    Переходя к другим элементам несортированного сегмента, перемещаем более
    крупные элементы в отсортированном сегменте вверх по списку, пока не встретим
    элемент меньше x или не дойдём до конца списка. В первом случае x помещается
    на правильную позицию. """
    # Сортировку начинаем со второго элемента так как первый элемент уже
    # отсортирован
    for i in range(1, len(nums)):
        item_to_insert = nums[i]
        # Сохраняем ссылку на индекс предыдущего элемента
        j = i - 1
        # Элементы отсортированного сегмента перемещаем вперед, если они
        # больше элемента для вставки
        while j >= 0 and nums[j] > item_to_insert:
            nums[j + 1] = nums[j]
            j -= 1
        # Вставляем элемент
        nums[j + 1] = item_to_insert


def partition(nums, low, high):
    # Выбираем средний элемент в качестве опорного
    # Также возможен выбор первого, последнего
    # или произвольного элемента в качестве опорного
    pivot = nums[(low + high) // 2]
    i = low - 1
    j = high + 1
    while True:
        i += 1
        while nums[i] < pivot:
            i += 1

        j -= 1
        while nums[j] > pivot:
            j -= 1

        if i >= j:
            return j

        # Если элемент с индексом i (слева от опорного) больше, чем элемент с
        # индексом j (справа от опорного), меняем их местами

        nums[i], nums[j] = nums[j], nums[i]


# 0(n log n).
def quick_sort(nums):
    """Быстрая сортировка чаще всего не сможет разделить массив на равные
    части. Это потому, что весь процесс зависит от того, как мы выбираем
    опорный элемент. Нам нужно выбрать опору так, чтобы она была примерно
    больше половины элементов и, следовательно, примерно меньше, чем другая
    половина элементов. Каким бы интуитивным ни казался этот процесс,
    это очень сложно сделать.

    Подумайте об этом на мгновение — как бы вы выбрали адекватную опору для
    вашего массива? В истории быстрой сортировки было представлено много идей о
    том, как выбрать центральную точку — случайный выбор элемента, который не
    работает из-за того, что «дорогой» выбор случайного элемента не гарантирует
    хорошего выбора центральной точки; выбор элемента из середины; выбор медианы
    первого, среднего и последнего элемента; и еще более сложные рекурсивные
    формулы.

    Самый простой подход — просто выбрать первый (или последний) элемент. По
    иронии судьбы, это приводит к быстрой сортировке на уже отсортированных (или
    почти отсортированных) массивах.

    Именно так большинство людей выбирают реализацию быстрой сортировки, и,
    так как это просто и этот способ выбора опоры является очень эффективной
    операцией, и это именно то, что мы будем делать.

    Теперь, когда мы выбрали опорный элемент — что нам с ним делать? Опять же,
    есть несколько способов сделать само разбиение. У нас будет «указатель» на
    нашу опору, указатель на «меньшие» элементы и указатель на «более крупные»
    элементы.

    Цель состоит в том, чтобы переместить элементы так, чтобы все элементы,
    меньшие, чем опора, находились слева от него, а все более крупные элементы
    были справа от него. Меньшие и большие элементы не обязательно будут
    отсортированы, мы просто хотим, чтобы они находились на правильной стороне
    оси. Затем мы рекурсивно проходим левую и правую сторону оси. """

    # Создадим вспомогательную функцию которая вызывается рекурсивно
    def _quick_sort(items, low, high):
        if low < high:
            # Получаем индекс элемента относительно которого разделим
            # последовательность
            split_index = partition(items, low, high)
            _quick_sort(items, low, split_index)
            _quick_sort(items, split_index + 1, high)

    _quick_sort(nums, 0, len(nums) - 1)


if __name__ == "__main__":
    import random

    lst = [random.randint(1, 100) for i in range(10)]
    print(lst)
    quick_sort(lst)
    insertion_sort(lst)
    bubble_sort(lst)
    print(lst)
